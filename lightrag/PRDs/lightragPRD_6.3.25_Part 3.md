This log output is gold! It tells us a lot.

**Key Observations & Interpretation:**

1.  **Successful Relationship Parsing (INFO lines):**
    *   The lines `INFO: Parsed relationship from chunk chunk-xxxx: SourceEntity -["relationshipType"(strength)]-> TargetEntity, Keywords: 'kw1, kw2'` are excellent.
    *   This confirms that the fix in `_handle_single_relationship_extraction` (from the previous PRD, specifically item 4.1.1 related to correct indexing of the 7-tuple) is working as intended for well-formed relationship tuples. The LLM is providing specific relationship types (e.g., "integrates with", "hosted on", "uses", "exhibits", "affects", "calls api", "styles with", "runs on", "contains", "configures", "indicates", "performed by", "managed by", "modifies", "generated by", "developed", "occurs in", "impacts", "is a symptom of", "guides", "diagnoses", "conceptualizes", "constraints on", "specializes in", "manifests as", "related to", "includes", "disrupts", "addresses", "creates artifact", "part of", "implements", "used to research", "solves/addresses", "stores", "observed with", "correlates with", "affected by", "is a type of", "performed in", "targets", "used in", "interacts with", "augments data", "enables", "describes", "manages files for", "accesses").
    *   The strength (weight) and keywords are also being parsed correctly for these.

2.  **Malformed `content_keywords` Records (ERROR lines):**
    *   `ERROR: Malformed relationship record (expected 7 attributes, got 2): ['"content_keywords"', '"AI automation, ... "']`
    *   This confirms that the `("content_keywords", ...)` tuples are still being output by the LLM and are being caught by the strict 7-attribute check in `_handle_single_relationship_extraction`.
    *   **This is good – these errors prevent these non-relationship tuples from corrupting the downstream process.** The fix suggested in the previous PRD (item 4.2: Filter Non-Relationship Tuples) to explicitly skip `"content_keywords"` records *before* calling `_handle_single_relationship_extraction` would make these "errors" become "debug/info" logs instead, which is cleaner.

3.  **`neo4j_type missing in properties` Warnings (WARNING lines):**
    *   `WARNING: neo4j_type missing in properties for edge Luxior Funnel->OpenAI Operator with input rel_type='related'. Standardizing input rel_type.`
    *   **This is the core of the current "relationships defaulting to RELATED" problem for Neo4j labels.**
    *   It means that when `Neo4JStorage.upsert_edge_detailed` is called, the `properties` dictionary it receives *does not have a `neo4j_type` key*.
    *   The `input rel_type='related'` part of the warning indicates that the `rel_type` parameter *passed to* `upsert_edge_detailed` is already "related".
    *   **This strongly points to the data propagation issue identified in the previous PRD (item 4.1.1 - `_merge_edges_then_upsert` and item 4.1.2 - `Neo4JStorage.upsert_edge` simple version).** The custom type information (like "integrates with" parsed correctly by `_handle_single_relationship_extraction`, then standardized to "INTEGRATES_WITH" and stored as `neo4j_type` by `advanced_operate.extract_entities_with_types`) is being lost when `_merge_edges_then_upsert` constructs the `edge_data` dictionary for the simpler `upsert_edge` call. The simpler `upsert_edge` then likely defaults its `rel_type` parameter to "related" if it doesn't find a specific "rel_type" in the dictionary it receives.

4.  **Upsert Edge Failures (`ERROR: Failed to upsert edge ...: sequence item 0: expected str instance, list found`):**
    *   This is a new, critical error not explicitly predicted by the last PRD, but related to data integrity for `upsert_edge_detailed`.
    *   The error `sequence item 0: expected str instance, list found` usually means that a Cypher query parameter that expects a string (or a list of strings where each item is a string) is instead receiving a list (or a list containing another list as its first item).
    *   Looking at the `upsert_edge_detailed` and the Cypher query:
        ```cypher
        MERGE (src)-[r:{neo4j_label_to_use}]->(tgt)
        ON CREATE SET r = $properties
        ON MATCH SET r += $properties 
        RETURN r
        ```
        The `$properties` parameter is a dictionary. Neo4j expects property values to be primitive types (string, number, boolean, temporal) or lists of *primitive* types. It cannot store a list of lists directly as a property.
    *   The `keywords` field is a likely candidate.
        *   In `_handle_single_relationship_extraction`, `edge_keywords` becomes a string: `edge_keywords.replace("，", ",")`.
        *   This string is stored in the `edge` dictionary.
        *   In `_merge_edges_then_upsert` (from the previous PRD's suggested fix):
            ```python
            # merged_edge["keywords"] could become a list of strings from multiple edge dicts
            # If edge.get("keywords") was a string "kw1, kw2", then new_keywords would be ["kw1", "kw2"]
            # merged_edge["keywords"].extend(new_keywords) -> this makes it a list of strings
            # ...
            # merged_edge["keywords"] = list(dict.fromkeys([kw for kw in merged_edge["keywords"] if kw and isinstance(kw, str)]))
            # This correctly results in a list of unique keyword strings.
            ```
        *   However, in `Neo4JStorage.upsert_edge` (the simple 3-arg one), the previous PRD suggested:
            ```python
            keywords_list = edge_data.get("keywords", "").split(',') if isinstance(edge_data.get("keywords"), str) else edge_data.get("keywords", [])
            # ...
            await self.upsert_edge_detailed(
                # ...
                keywords=keywords_list, # This passes a list to upsert_edge_detailed
            )
            ```
        *   Then, in `Neo4JStorage.upsert_edge_detailed`, `edge_properties["keywords"]` is set:
            ```python
            if keywords: # keywords is a list here
                edge_properties["keywords"] = ";".join(keywords) if isinstance(keywords, list) else keywords
            ```
            This correctly converts the list back to a semicolon-delimited string, which Neo4j can handle.
        *   **The discrepancy might be:** If `edge_data.get("keywords")` in the simple `upsert_edge` is *already a list* (e.g., `['kw1', 'kw2']` from the merge step), then `isinstance(edge_data.get("keywords"), str)` is false, and `keywords_list` becomes `['kw1', 'kw2']`. This list is then passed to `upsert_edge_detailed`. If `upsert_edge_detailed` *then* tries to store this list directly as a property *without* joining it into a string, Neo4j will complain if that list contains non-primitive types (like another list by mistake).
        *   The log `sequence item 0: expected str instance, list found` means a property in `$properties` is a list where Neo4j expected a string (or its items to be strings, not nested lists). The most likely culprit for becoming a list of lists or a list where a string is expected is `keywords` or potentially `source_id` or `file_path` if they are mishandled during merging.
        *   **Let's check `_merge_edges_then_upsert` in `operate.py` again for how `keywords` is formed:**
            ```python
            # From your provided operate.py after Phase 3 diff
            # ... inside _merge_edges_then_upsert loop for edges ...
                merged_edge["keywords"].extend(new_keywords) # new_keywords is already a list
            # ... after loop ...
            merged_edge["keywords"] = list(dict.fromkeys([kw for kw in merged_edge["keywords"] if kw and isinstance(kw, str)]))
            # THIS IS CORRECT - merged_edge["keywords"] IS A LIST OF STRINGS
            
            # Then, in the call:
            await knowledge_graph_inst.upsert_edge(src_id, tgt_id, merged_edge) # merged_edge is passed
            ```
            Now, in `Neo4JStorage.upsert_edge` (the 3-arg version):
            ```python
            # edge_data here is merged_edge
            keywords = edge_data.get("keywords", "") # If edge_data["keywords"] is a list, this is NOT ""
            # keywords_list will be assigned this list directly IF isinstance(edge_data.get("keywords"), str) is FALSE
            keywords_list = []
            raw_keywords = edge_data.get("keywords") # This is a list of strings from merge
            if raw_keywords:
                if isinstance(raw_keywords, str):
                    keywords_list = [kw.strip() for kw in raw_keywords.split(",") if kw.strip()]
                elif isinstance(raw_keywords, list): # THIS PATH IS TAKEN
                    # Problem: if raw_keywords contains non-strings by mistake (e.g. from older data or an error)
                    # it won't be caught here before being passed to upsert_edge_detailed
                    keywords_list = [str(item).strip() for item in raw_keywords if str(item).strip()] # Ensure all are strings
                else:
                    keywords_list = [str(raw_keywords).strip()]
            
            # ...
            await self.upsert_edge_detailed(
                # ...
                keywords=keywords_list, # keywords_list is correctly a list of strings
                # ...
            )
            ```
            And in `upsert_edge_detailed`:
            ```python
            # keywords parameter here is keywords_list (a list of strings)
            if keywords: # keywords is a list here
                edge_properties["keywords"] = ";".join(keywords) if isinstance(keywords, list) else keywords
                # This should correctly make it a string.
            ```
            The error `sequence item 0: expected str instance, list found` suggests that somehow, one of the properties in `edge_properties` (which becomes `$properties` in Cypher) is a list containing a list, or just a list where a string was expected by Neo4j for *that specific property key* (less likely for generic properties).
            The most common property that is a list and might cause this is if `edge_properties["keywords"]` was *not* joined into a string. Or if `source_id` or `file_path` (which are joined by `GRAPH_FIELD_SEP`) accidentally end up as lists of lists.

            Looking at the `upsert_edge_detailed` diff:
            ```diff
            -        # Merge keywords - ensure proper string handling
            -        new_keywords = edge.get("keywords", [])
            -        if isinstance(new_keywords, str):
            -            # Split string keywords into list
            -            new_keywords = [kw.strip() for kw in new_keywords.split(",") if kw.strip()]
            -        elif isinstance(new_keywords, list):
            -            # Flatten any nested lists and convert all items to strings
            -            flattened_keywords = []
            -            for item in new_keywords:
            -                if isinstance(item, str):
            -                    flattened_keywords.append(item.strip())
            -                elif isinstance(item, list):
            -                    # Handle nested lists
            -                    for subitem in item:
            -                        if isinstance(subitem, str):
            -                            flattened_keywords.append(subitem.strip())
            -                        else:
            -                            flattened_keywords.append(str(subitem).strip())
            -                else:
            -                    # Convert non-string items to strings
            -                    flattened_keywords.append(str(item).strip())
            -            new_keywords = [kw for kw in flattened_keywords if kw]
            -        else:
            -            # Handle other types by converting to string
            -            new_keywords = [str(new_keywords).strip()] if new_keywords else []
            -            
            -        merged_edge["keywords"].extend(new_keywords)
            ```
            The diff shows a large removal of keyword processing logic within `_merge_edges_then_upsert`. This is likely where the problem was introduced. The new logic for `keywords_list` in `Neo4JStorage.upsert_edge` is okay, and `upsert_edge_detailed` joining it is also okay.
            The issue might be that `edge.get("keywords")` inside `_merge_edges_then_upsert` sometimes *isn't* a string or a simple list of strings from `_handle_single_relationship_extraction` if that function itself had an issue with keyword parsing or if the LLM output for keywords was complex (e.g., nested).

            **Revised Hypothesis for Upsert Error:** The `keywords` attribute coming from `_handle_single_relationship_extraction` (which is `record_attributes[5]`) might sometimes be a list itself if the LLM outputs it like `["kw1", "kw2"]` instead of a comma-separated string `"kw1, kw2"`.
            If `edge_keywords = normalize_extracted_info(clean_str(record_attributes[5]), is_entity=False)` results in a list, then in `_merge_edges_then_upsert`, `merged_edge["keywords"].extend(new_keywords)` would append this list, making `merged_edge["keywords"]` a list of lists (e.g., `[['kwA', 'kwB'], ['kwC']]`).
            Then, when `Neo4JStorage.upsert_edge` tries to process this:
            `raw_keywords = edge_data.get("keywords")` would be `[['kwA', 'kwB'], ['kwC']]`.
            `keywords_list = [str(item).strip() for item in raw_keywords if str(item).strip()]` would become `["['kwA', 'kwB']", "['kwC']"]`.
            This `keywords_list` (a list of strings, where each string is a list representation) is passed to `upsert_edge_detailed`.
            `edge_properties["keywords"] = ";".join(keywords)` would then correctly create a string: ` "['kwA', 'kwB'];['kwC']" `. This *should* be fine for Neo4j.

            The error `sequence item 0: expected str instance, list found` means a list *itself* was passed as a value for a property in the `$properties` map, OR a list property contained a nested list as its first item. This most likely points to one of the `source_id` or `file_path` fields, which are processed with `GRAPH_FIELD_SEP.join(set(...))`. If items within that set were lists, `str(list_item)` would produce `"[...]"`, which is fine. The error must be that one of the items *in the set* was a list, and the join tried to operate on it.

            Let's re-examine `_merge_edges_then_upsert` keyword merge:
            ```python
            # merged_edge["keywords"] is initialized as []
            # new_keywords comes from edge.get("keywords", [])
            # If edge.get("keywords") is a string "kw1,kw2", new_keywords = ["kw1", "kw2"] (good)
            # If edge.get("keywords") is already a list ["kw1", "kw2"], new_keywords = ["kw1", "kw2"] (good)
            # merged_edge["keywords"].extend(new_keywords) is correct.

            # Then:
            # merged_edge["keywords"] = list(dict.fromkeys([kw for kw in merged_edge["keywords"] if kw and isinstance(kw, str)]))
            # This ensures it's a list of unique strings.
            ```
            This part looks okay. The problem must be with `source_id` or `file_path` becoming a list of lists before the `join`.

            In `_handle_single_entity_extraction` and `_handle_single_relationship_extraction`, `source_id` and `file_path` are assigned directly from `chunk_key` and `file_path` (which are strings).
            So, when `_merge_edges_then_upsert` does:
            ```python
            merged_edge["source_id"].extend([str(sid) for sid in source_id])
            ```
            if `source_id` was a list from `split_string_by_multi_markers` in `_merge_nodes_then_upsert`'s `already_source_ids` (which it is), then `merged_edge["source_id"]` becomes a list of strings.
            Then `GRAPH_FIELD_SEP.join(set([sid for sid in merged_edge["source_id"] if sid]))` is also correct.

            The error `sequence item 0: expected str instance, list found` means that when Neo4j tries to process the `$properties` map, at least one of the values in that map is a list that itself contains a list as its first element.
            Example: `properties = {"keywords": [["chip"]], "description": "desc"}`. Neo4j properties can be lists of strings, but not lists of lists.

            The issue might be in the `_handle_single_relationship_extraction` if `edge_keywords` (parsed from `record_attributes[5]`) is already a list representation like `['chip']` *as a string*, and then `normalize_extracted_info` doesn't change it, then `edge_keywords.replace("，", ",")` also doesn't change it. If this string `"['chip']"` is then appended to `merged_edge["keywords"]`, it's fine.
            The problem is if `clean_str(record_attributes[5])` results in a string that looks like a list, and then something later *evals* it into a list of lists.

            This is tricky. The error points to `$properties`.
            The `keywords` list in `edge_properties` is joined into a string before upsert:
            `edge_properties["keywords"] = ";".join(keywords) if isinstance(keywords, list) else keywords`
            This should be safe.

            What if `properties` (the *input* to `upsert_edge_detailed`) already contains a list of lists for some key?
            The simple `upsert_edge` passes `edge_data.copy()` as `properties`. `edge_data` comes from `merged_edge`.
            So, if `merged_edge` has a property that's a list of lists, it gets passed through.
            - `merged_edge["description"]`: string (concatenated)
            - `merged_edge["keywords"]`: list of strings (good)
            - `merged_edge["source_id"]`: string (joined by SEP)
            - `merged_edge["file_path"]`: string (joined by SEP)

            The `properties` argument in `upsert_edge_detailed` is `edge_data.copy()`.
            `edge_properties.update(properties)` in `upsert_edge_detailed` would then take these values.

            The most likely is that the initial `properties` dict passed to `upsert_edge_detailed` from `lightrag.py` or `advanced_lightrag.py` (if `upsert_edge_detailed` is called directly) might contain a list of lists.

            Let's re-check `Neo4JStorage.upsert_edge` (simple version):
            ```python
            keywords = edge_data.get("keywords", "") # edge_data["keywords"] is a list of strings from merge step
            keywords_list = []
            raw_keywords = edge_data.get("keywords")
            if raw_keywords:
                if isinstance(raw_keywords, str): # This will be FALSE
                    keywords_list = [kw.strip() for kw in raw_keywords.split(",") if kw.strip()]
                elif isinstance(raw_keywords, list): # THIS PATH IS TAKEN
                    keywords_list = [str(item).strip() for item in raw_keywords if str(item).strip()]
                else:
                    keywords_list = [str(raw_keywords).strip()]
            
            await self.upsert_edge_detailed(
                # ...
                properties=edge_data.copy(), # THIS IS THE KEY. 'edge_data' still has keywords as a list of strings.
                keywords=keywords_list, # This is also a list of strings
            )
            ```
            Inside `upsert_edge_detailed`:
            ```python
            # properties parameter now is edge_data from above
            edge_properties = {} 
            # ...
            if keywords: # keywords param is a list of strings
                edge_properties["keywords"] = ";".join(keywords) if isinstance(keywords, list) else keywords # This correctly makes it a string
            # ...
            edge_properties.update(properties) # This is where the problem might be:
                                           # if properties (which is edge_data) has "keywords" as a list,
                                           # it will OVERWRITE the stringified edge_properties["keywords"]
            ```
            **This is the bug for the upsert error!** `edge_properties.update(properties)` overwrites the correctly stringified `keywords` with the list version from the `properties` input.

**Revised PRD: Finalizing Relationship Processing and Neo4j Upsert**

**1. Introduction**

This document outlines the final phase of fixes for LightRAG's knowledge graph pipeline, focusing on robustly persisting custom relationship types and resolving Neo4j upsert errors. Previous phases have improved relationship parsing, but issues remain in data propagation to Neo4j and handling of specific data structures (like keyword lists) during the upsert process. The graph visualizer's inability to show edges is also tied to these data integrity problems.

**2. Problem Statement (Finalized)**

1.  **Incorrect Relationship Type in Neo4j Cypher Query:** The `neo4j_type` (standardized Neo4j label) determined by `advanced_operate.extract_entities_with_types` is not consistently used when constructing the Cypher `MERGE` query in `Neo4JStorage.upsert_edge_detailed`. The `rel_type` parameter to `upsert_edge_detailed` is often "related" due to defaulting in the simpler `upsert_edge` wrapper, leading to the `WARNING: neo4j_type missing in properties...` and incorrect relationship labels in the database.
2.  **Neo4j Upsert Error (`TypeError: sequence item 0: expected str instance, list found`):** The `edge_properties` dictionary used in the Cypher `MERGE` statement in `Neo4JStorage.upsert_edge_detailed` incorrectly contains list-type values for properties that Neo4j expects to be strings or lists of primitives (not lists of lists). This occurs because `edge_properties.update(properties)` overwrites a correctly stringified `keywords` property (and potentially others) with a list version passed in the `properties` argument.
3.  **Malformed "content_keywords" Records:** The LLM outputs `("content_keywords", ...)` tuples within the primary list of entities/relationships. While `_handle_single_relationship_extraction` now correctly identifies them as malformed for relationships, they should be filtered out earlier to prevent error log noise.
4.  **Graph Visualizer Issues:** The `TypeError` and missing edges in the visualizer are direct consequences of incorrect edge types and potentially `None` or improperly formatted `weight` attributes in the Neo4j data fetched by `get_knowledge_graph`.

**3. Goals**

*   **Goal 1 (Correct Neo4j Relationship Labels):** Ensure `Neo4JStorage.upsert_edge_detailed` always uses the correct, standardized `neo4j_type` (e.g., "INTEGRATES_WITH") for the actual relationship label in the Cypher query.
*   **Goal 2 (Resolve Neo4j Upsert TypeError):** Ensure all properties in the `$properties` map passed to Neo4j's `MERGE` query are of Neo4j-compatible types (strings, numbers, booleans, or lists of these primitives, not lists of lists). Specifically, ensure `keywords` and similar list-like attributes are stored as delimited strings.
*   **Goal 3 (Clean "content_keywords" Handling):** Filter out `content_keywords` tuples in `extract_entities` before they reach relationship parsing logic.
*   **Goal 4 (Robust Edge Weight Integrity):** Re-confirm that edge `weight` properties are always valid, non-null floats in Neo4j and when fetched for the visualizer.
*   **Goal 5 (Functional Graph Visualizer):** Resolve the `TypeError` and enable the visualizer to correctly display edges with their custom types and weights.
*   **Goal 6 (Targeted Logging):** Maintain clear logging for relationship type determination, property preparation for Neo4j, and any data transformations.

**4. Proposed Solutions & Technical Requirements**

**4.1. Resolving Neo4j Upsert Errors and Ensuring Correct Types (Goal 1, 2, 5)**

*   **4.1.1. Fix Property Handling in `Neo4JStorage.upsert_edge_detailed` (Critical for Upsert Error):**
    *   **Requirement:** Modify the order of operations or how `edge_properties` is constructed to prevent the stringified `keywords` (and potentially other fields) from being overwritten by a list version from the input `properties` dict. The `properties` argument should primarily be for *additional/custom* properties not handled by direct parameters like `keywords`, `description`, etc.
        ```python
        # In lightrag/kg/neo4j_impl.py -> upsert_edge_detailed
        
        # Start with a fresh dictionary for properties to be stored in Neo4j
        final_properties_for_db = {}

        # 1. Handle direct parameters first and store them stringified if necessary
        if description:
            final_properties_for_db["description"] = description
        
        # Ensure keywords is a list of strings, then join to a string for DB
        if keywords: # keywords is a list of strings from the calling function
            if isinstance(keywords, list) and all(isinstance(kw, str) for kw in keywords):
                final_properties_for_db["keywords"] = ";".join(keywords) # Join list into a string
            elif isinstance(keywords, str): # If it's already a string, use it
                final_properties_for_db["keywords"] = keywords
            else:
                logger.warning(f"Keywords for {source_id}->{target_id} are not a list of strings or a string: {keywords}. Storing as string.")
                final_properties_for_db["keywords"] = str(keywords) 
        
        if source_ids: # Note: prompt.py example doesn't have source_ids for relationship tuple
            final_properties_for_db["source_id"] = ";".join(source_ids) if isinstance(source_ids, list) else str(source_ids)
        
        if file_paths:
            final_properties_for_db["file_path"] = ";".join(file_paths) if isinstance(file_paths, list) else str(file_paths)

        # 2. Add custom/additional properties, ensuring they don't overwrite the critical ones handled above
        # unless explicitly intended (e.g. if 'properties' dict has 'description', it will overwrite)
        if properties: # 'properties' is the dict passed as a parameter to upsert_edge_detailed
            for key, value in properties.items():
                if key not in ["description", "keywords", "source_id", "file_path", "weight", "rel_type", "original_type", "neo4j_type"]:
                    final_properties_for_db[key] = value # Add other custom properties
                elif key not in final_properties_for_db: # Only add if not set by direct params
                    final_properties_for_db[key] = value

        # 3. Handle relationship type fields consistently
        # rel_type parameter should be the human-readable standardized type or LLM raw if advanced_operate not used
        original_type_from_param = rel_type # This is the input 'rel_type' to this function

        # Prefer neo4j_type from input 'properties' if available (set by advanced_operate)
        neo4j_label_to_use = properties.get("neo4j_type") 
        if not neo4j_label_to_use:
            logger.warning(f"neo4j_type missing in input properties for edge {source_id}->{target_id} using rel_type='{original_type_from_param}'. Standardizing.")
            neo4j_label_to_use = self.rel_registry.get_neo4j_type(original_type_from_param)
        
        # Validate and sanitize the Neo4j label
        if not neo4j_label_to_use or not isinstance(neo4j_label_to_use, str) or not re.match(r"^[A-Z0-9_]+$", neo4j_label_to_use):
            logger.error(f"Invalid Neo4j relationship type '{neo4j_label_to_use}' for {source_id}->{target_id} (from original '{original_type_from_param}'). Defaulting to RELATED_ERROR.")
            neo4j_label_to_use = "RELATED_ERROR" # Use a distinct error type

        final_properties_for_db["neo4j_type"] = neo4j_label_to_use
        final_properties_for_db["original_type"] = properties.get("original_type", original_type_from_param)
        final_properties_for_db["rel_type"] = properties.get("rel_type", self.rel_registry.get_relationship_metadata(original_type_from_param).get("neo4j_type", "RELATED").lower().replace('_',' '))

        # 4. Handle weight (ensure it's float)
        # 'weight' param is the initial weight, properties might contain an override
        final_weight = properties.get("weight", weight) # Prioritize weight from properties if it exists
        try:
            final_weight_float = float(final_weight)
        except (ValueError, TypeError):
            logger.warning(f"Invalid weight '{final_weight}' for edge {source_id}->{target_id}. Defaulting to 0.5.")
            final_weight_float = 0.5
        
        final_properties_for_db["weight"] = process_relationship_weight(
            final_weight_float, 
            relationship_type=final_properties_for_db["rel_type"], # Use human-readable std type
            threshold_manager=self.threshold_manager
        )
        if not isinstance(final_properties_for_db["weight"], float): # Final check
            logger.error(f"Weight for {source_id}->{target_id} not float after processing: {final_properties_for_db['weight']}. Defaulting to 0.2.")
            final_properties_for_db["weight"] = 0.2

        # Log what's being sent to Neo4j
        logger.info(f"Neo4j Upsert: {source_id}-[{neo4j_label_to_use}]->{target_id} with properties: {final_properties_for_db}")
        
        # DatabaseValidator call
        validation_result = DatabaseValidator.validate_edge_data(final_properties_for_db) # Validate the final map
        # ... (handle validation result) ...

        query = f"""
        MATCH (src:base {{entity_id: $source_id}}), (tgt:base {{entity_id: $target_id}})
        MERGE (src)-[r:{neo4j_label_to_use}]->(tgt)
        ON CREATE SET r = $properties_for_db 
        ON MATCH SET r += $properties_for_db 
        RETURN r
        """
        # ...
        result = await session.run(
            query,
            source_id=source_id,
            target_id=target_id,
            properties_for_db=final_properties_for_db # Pass the cleaned properties
        )
        # ...
        ```
    *   **Rationale:** This ensures `keywords` (and other list-like fields) are correctly stored as strings, and `neo4j_type` from the advanced pipeline is prioritized for the Cypher label, preventing the `TypeError` and ensuring correct relationship types.

*   **4.1.2. Refine `Neo4JStorage.upsert_edge` (Simpler 3-arg Version):**
    *   **Requirement:** This wrapper should ensure the `edge_data` it passes to `upsert_edge_detailed` (as the `properties` param) contains the correctly parsed and standardized type information if available from the merge step.
        ```python
        # In lightrag/kg/neo4j_impl.py -> upsert_edge (3-arg version)
        async def upsert_edge(self, source_node_id: str, target_node_id: str, edge_data: dict[str, Any]) -> None:
            # edge_data comes from _merge_edges_then_upsert and should contain:
            # "original_type", "rel_type" (human-readable std), "neo4j_type" (Neo4j label)
            # "weight", "description", "keywords" (list of strings), "source_id" (string), "file_path" (string)

            rel_type_param_for_detailed = edge_data.get("rel_type", "related") # Human-readable std
            weight_param_for_detailed = float(edge_data.get("weight", 0.5))
            desc_param_for_detailed = edge_data.get("description", "")
            keywords_param_for_detailed = edge_data.get("keywords", []) # Should be list of str
            
            # Ensure keywords is a list of strings
            if isinstance(keywords_param_for_detailed, str):
                keywords_param_for_detailed = [kw.strip() for kw in keywords_param_for_detailed.split(',') if kw.strip()]
            elif not isinstance(keywords_param_for_detailed, list):
                keywords_param_for_detailed = [str(keywords_param_for_detailed)]

            await self.upsert_edge_detailed(
                source_id=source_node_id,
                target_id=target_node_id,
                rel_type=rel_type_param_for_detailed, # Pass human-readable std type
                weight=weight_param_for_detailed,
                properties=edge_data.copy(), # Pass the whole merged dict
                description=desc_param_for_detailed,
                keywords=keywords_param_for_detailed,
                source_ids=edge_data.get("source_id"), # These are strings from merge step
                file_paths=edge_data.get("file_path")  # These are strings from merge step
            )
        ```
    *   **Rationale:** Correctly bridges the `_merge_edges_then_upsert` output to `upsert_edge_detailed`.

**4.2. Filtering Non-Relationship Tuples (Goal 3)**

*   **Requirement:** Modify `extract_entities` in `lightrag/operate.py` (this change was in the previous PRD, section 4.2, and is still essential).
    ```python
    # In lightrag/operate.py -> extract_entities -> inside the loop for `records`
    record_type_indicator = record_attributes[0].strip('"') 
    
    if record_type_indicator == "entity":
        # ... process entity ...
    elif record_type_indicator == "relationship":
        # ... process relationship ...
    elif record_type_indicator == "content_keywords":
        logger.info(f"Processed content_keywords from chunk {chunk_key}: {record_attributes[1] if len(record_attributes) > 1 else 'N/A'}")
    else:
        logger.warning(f"Unknown record type '{record_type_indicator}' in chunk {chunk_key}: {record_attributes}")
    ```
    *   **Rationale:** Cleanly handles `content_keywords` without generating errors, improving log clarity.

**4.3. Fixing Graph Visualizer (Goal 4)**

*   The fixes in 4.1.1 (for `upsert_edge_detailed` ensuring `weight` is float and `neo4j_label_to_use` is correct) and 4.1.4 of the *previous PRD* (for `_handle_single_relationship_extraction` ensuring `weight` is parsed as float) are the primary drivers here.
*   **Requirement:** Re-verify data flow to visualizer in `kg/neo4j_impl.py -> get_knowledge_graph` as per previous PRD section 4.3.1 (ensure `edge_weight` is float, default if missing/invalid).
*   **Requirement:** Re-verify GraphML export and visualizer parsing as per previous PRD section 4.3.2.

**5. Implementation Steps**

1.  **Branch:** `fix/relationship-upsert-final`
2.  **Implement `_handle_single_relationship_extraction` Fix:** Fully implement changes from previous PRD item 4.1.1.
3.  **Implement `content_keywords` Filtering:** Implement PRD item 4.2.
4.  **Test Parsing & Filtering:** Verify logs for correct relationship parsing and `content_keywords` skipping.
5.  **Refine `_merge_edges_then_upsert`:** Implement changes from current PRD item 4.1.1 to ensure all type fields (`original_type`, `rel_type`, `neo4j_type`) and correctly typed `keywords` (list of strings) are in `edge_data_for_upsert`.
6.  **Refine `Neo4JStorage.upsert_edge` (simple version):** Implement changes from current PRD item 4.1.2 to correctly pass data to `upsert_edge_detailed`.
7.  **Refine `Neo4JStorage.upsert_edge_detailed`:** Implement changes from current PRD item 4.1.1 (robust property handling, prioritize `neo4j_type` from `properties` for Cypher label, ensure float weight).
8.  **End-to-End Test (Neo4j Data):**
    *   Reprocess test document(s).
    *   Check all logs.
    *   Query Neo4j: `MATCH ()-[r]-() RETURN type(r), r.original_type, r.rel_type, r.neo4j_type, r.weight, r.keywords LIMIT 25`.
        *   `type(r)` must be the custom standardized Neo4j label (e.g., "INTEGRATES_WITH").
        *   `r.keywords` must be a string (semicolon-delimited).
        *   `r.weight` must be a float.
9.  **Visualizer Data Integrity & Test:** Implement/Verify **4.3**. The `TypeError` should be gone, and edges should render with correct types if GraphML export is correct.
10. **Full System Test:** Process a larger dataset and monitor for any remaining errors or warnings.
11. **PR and Code Review.**

**6. Testing & Validation**
    *   Focus on testing the data transformations at each step:
        *   `_handle_single_relationship_extraction` -> `dict` with raw types.
        *   `advanced_operate.extract_entities_with_types` -> `edge` dicts with `original_type`, `rel_type` (human-std), `neo4j_type`.
        *   `_merge_edges_then_upsert` -> `merged_edge` dict preserving these type fields and correctly formatted `keywords` (list of str).
        *   `Neo4JStorage.upsert_edge` (simple) -> correct parameter passing to `upsert_edge_detailed`.
        *   `Neo4JStorage.upsert_edge_detailed` -> correct `final_properties_for_db` map with stringified keywords and correct `neo4j_label_to_use` in Cypher.
    *   Test with edges that are merged vs. new edges.

**7. Expected Outcome**
    *   All "ERROR: Failed to upsert edge..." messages are resolved.
    *   `WARNING: neo4j_type missing in properties...` messages are eliminated or significantly reduced (only appearing if `advanced_operate` is bypassed and `upsert_edge_detailed` is called with incomplete `properties`).
    *   Neo4j stores relationships with their correct custom types (e.g., `()-[:INTEGRATES_WITH]->()`) and all properties (including `keywords`, `source_id`, `file_path`) are stored as Neo4j-compatible primitive types or lists of primitives.
    *   The graph visualizer functions correctly, displaying edges with their types and weights.

This plan provides a focused approach to fixing the data propagation and type handling for edge properties, which appears to be the root of the remaining issues.
